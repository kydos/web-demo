// Generated by CoffeeScript 1.7.1

/*
  jshapes is a web implementation of the "shapes" application used
   by DDS vendors to demonstrate interoperability.  That said this
   simple application tries to show how DDS can be effectively used to
   stream and render real-time data in a web-browser.

   For information contact angelo@icorsaro.net
 */

(function() {
  var $, JShapesProperties, Shape, ShapeColor, animate, awsServer, bindShape, bouncingCircles, bouncingDynamic, bouncingSquares, bouncingTriangles, circleBBox, circleDR, circleDW, circleTopic, clearCircles, clearPS, clearSquares, clearTopicPubSub, clearTriangles, colorMap, computeThroughput, connect, demoServer, disableUI, disconnect, drawCircle, drawSquare, drawTriangle, drawTriangleShape, drqos, dscriptServer, dwqos, enableUI, exports, extraBuffering, inCircleCache, inSquareCache, inTriangleCache, initialiseCircleRenderCache, intialiseRenderCache, jshapes, linodeServerEU, linodeServerUS, localhost, outCircleCache, outCircleRenderCache, outSquareCache, outSquareRenderCache, outTriangleCache, outTriangleRenderCache, publishTopic, randomShape, root, runJShapes, runtime, squareBBox, squareDR, squareDW, squareTopic, start, stop, stripShape, subscribeTopic, triangleBBox, triangleDR, triangleDW, triangleTopic, unmatchedSubscriptionShape, z_;

  root = this;

  $ = jQuery;

  jshapes = {};

  z_ = coffez;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = jshapes;
    }
    exports.jshapes = jshapes;
  } else {
    root.jshapes = jshapes;
  }

  linodeServerEU = 'ws://88.80.185.102:9000';

  linodeServerUS = 'ws://66.175.212.58:9000';

  demoServer = 'ws://demo.prismtech.com:9000';

  awsServer = 'ws://54.72.1.3:9000';

  localhost = 'ws://localhost:9000';

  dscriptServer = localhost;

  extraBuffering = 25;

  runtime = new dds.runtime.Runtime();

  enableUI = function() {
    var clrb, pb, sb;
    pb = root.document.getElementById("showPubModalBtn");
    pb.disabled = false;
    sb = root.document.getElementById("showSubModalBtn");
    sb.disabled = false;
    clrb = root.document.getElementById("showClearModalBtn");
    return clrb.disabled = false;
  };

  disableUI = function() {
    var clrb, pb, sb;
    pb = root.document.getElementById("showPubModalBtn");
    pb.disabled = true;
    sb = root.document.getElementById("showSubModalBtn");
    sb.disabled = true;
    clrb = root.document.getElementById("showClearModalBtn");
    return clrb.disabled = true;
  };

  runtime.ondisconnect = function(e) {
    disableUI();
    return alert('Connection Failure! Please check your Internet connection');
  };

  runtime.onconnect = function() {
    var cb;
    cb = root.document.getElementById("connectBtn");
    cb.innerHTML = " Disconnect";
    cb.className = "btn btn-danger";
    cb.onclick = disconnect;
    return enableUI();
  };

  runtime.ondisconnect = function() {
    var cb;
    cb = root.document.getElementById("connectBtn");
    cb.innerHTML = " Connect";
    cb.className = "btn btn-default";
    cb.onclick = connect;
    return disableUI();
  };

  connect = function() {
    var sid;
    sid = root.document.getElementById("sessionId").value;
    console.log("SessionId: " + sid);
    return runtime.connect(dscriptServer, sid);
  };

  disconnect = function() {
    return runtime.disconnect();
  };

  clearTopicPubSub = function() {
    var topic;
    topic = JShapesProperties.clearTopic();
    switch (topic) {
      case "Circle":
        return clearCircles();
      case "Square":
        return clearSquares();
      case "Triangle":
        return clearTriangles();
    }
  };

  JShapesProperties = {
    logo: {
      img: new Image(),
      coord: {
        x: 280,
        y: 300
      }
    },
    bounds: {
      w: 501,
      h: 361
    },
    refresh: 40,
    canvas: function() {
      return root.document.getElementById("iShapeCanvas");
    },
    g2d: function() {
      return root.document.getElementById("iShapeCanvas").getContext("2d");
    },
    pubTopic: function() {
      return root.document.getElementById("pubTopicSelection").value.toString();
    },
    subTopic: function() {
      return root.document.getElementById("subTopicSelection").value.toString();
    },
    clearTopic: function() {
      return root.document.getElementById("clearTopicSelection").value.toString();
    },
    pubShapeColor: function() {
      return root.document.getElementById("pubColorSelection").value.toString();
    },
    pubShapeSize: function() {
      return parseInt(root.document.getElementById("pubTopicSize").value.toString(), 10);
    },
    pubShapeSpeedX: function() {
      return parseInt(root.document.getElementById("pubTopicSpeedX").value.toString(), 10);
    },
    pubShapeSpeedY: function() {
      return parseInt(root.document.getElementById("pubTopicSpeedY").value.toString(), 10);
    },
    subShapeHistory: function() {
      return parseInt(root.document.getElementById("subHistoryDepth").value, 10);
    },
    subShapeHistoryPolicy: function() {
      return dds.History.KeepLast(parseInt(root.document.getElementById("subHistoryDepth").value, 10));
    },
    pubShapePartitionPolicy: function() {
      return dds.Partition(root.document.getElementById("pubPartition").value);
    },
    subShapePartitionPolicy: function() {
      return dds.Partition(root.document.getElementById("subPartition").value);
    },
    pubShapeReliabilityPolicy: function() {
      return dds.Reliability.BestEffort;
    },
    subShapeReliabilityPolicy: function() {
      return dds.Reliability.BestEffort;
    },
    subShapeTimeFilter: function() {
      var tfv;
      tfv = parseInt(root.document.getElementById("subTFilter").value, 10);
      console.log("TimeFilter = " + tfv);
      if (tfv === 0) {
        return z_.None;
      } else {
        return z_.Some(dds.TimeFilter(tfv));
      }
    },
    subShapeContentFilter: function() {
      var fv;
      fv = root.document.getElementById("subCFilter").value;
      console.log("CFilter = " + fv);
      if (fv.length === 0) {
        return z_.None;
      } else {
        return z_.Some(dds.ContentFilter(fv));
      }
    },
    shapeReaderQos: function() {
      var baseqos, cfp, tfp;
      baseqos = new dds.DataReaderQos(JShapesProperties.subShapeReliabilityPolicy(), JShapesProperties.subShapePartitionPolicy(), JShapesProperties.subShapeHistoryPolicy());
      cfp = JShapesProperties.subShapeContentFilter();
      tfp = JShapesProperties.subShapeTimeFilter();
      baseqos = cfp !== z_.None ? baseqos.add(cfp.get()) : baseqos;
      if (tfp !== z_.None) {
        return baseqos.add(tfp.get());
      } else {
        return baseqos;
      }
    },
    shapeWriterQos: function() {
      return new dds.DataWriterQos(JShapesProperties.pubShapeReliabilityPolicy(), JShapesProperties.pubShapePartitionPolicy());
    },
    defaultShapeSize: 50
  };

  JShapesProperties.logo.img.src = "../assets/images/logo.png";

  ShapeColor = {
    red: "RED",
    green: "GREEN",
    blue: "BLUE",
    orange: "ORANGE",
    yellow: "YELLOW",
    magenta: "MAGENTA",
    cyan: "CYAN",
    gray: "GRAY",
    white: "WHITE",
    black: "BLACK"
  };

  colorMap = {};

  colorMap[ShapeColor.red] = "#cc3333";

  colorMap[ShapeColor.green] = "#99cc66";

  colorMap[ShapeColor.blue] = "#336699";

  colorMap[ShapeColor.orange] = "#ff9933";

  colorMap[ShapeColor.yellow] = "#ffff66";

  colorMap[ShapeColor.magenta] = "#cc99cc";

  colorMap[ShapeColor.cyan] = "#99ccff";

  colorMap[ShapeColor.gray] = "#666666";

  colorMap[ShapeColor.white] = "#ffffff";

  colorMap[ShapeColor.black] = "#000000";

  drqos = new dds.DataReaderQos(dds.Reliability.Reliable);

  dwqos = new dds.DataWriterQos(dds.Reliability.BestEffort);

  circleTopic = new dds.Topic(0, 'Circle', 'org.omg.dds.demo.ShapeType');

  squareTopic = new dds.Topic(0, 'Square', 'org.omg.dds.demo.ShapeType');

  triangleTopic = new dds.Topic(0, 'Triangle', 'org.omg.dds.demo.ShapeType');

  circleDR = null;

  squareDR = null;

  triangleDR = null;

  circleDW = null;

  squareDW = null;

  triangleDW = null;

  inCircleCache = z_.None;

  inSquareCache = z_.None;

  inTriangleCache = z_.None;

  outCircleRenderCache = z_.None;

  outSquareRenderCache = z_.None;

  outTriangleRenderCache = z_.None;

  outCircleCache = z_.None;

  outSquareCache = z_.None;

  outTriangleCache = z_.None;

  bindShape = dds.bind(function(s) {
    return s.color;
  });

  Shape = (function() {
    function Shape(color, shapesize, x, y, dx, dy) {
      this.color = color;
      this.shapesize = shapesize;
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
    }

    return Shape;

  })();

  randomShape = function(color, size, dx, dy) {
    var s;
    s = new Shape();
    s.color = color;
    s.shapesize = size;
    s.x = Math.floor(Math.random() * JShapesProperties.bounds.w);
    s.y = Math.floor(Math.random() * JShapesProperties.bounds.h);
    s.dx = dx;
    s.dy = dy;
    return s;
  };

  unmatchedSubscriptionShape = randomShape('GRAY', 40, 0, 0);

  stripShape = function(s) {
    var ss;
    ss = {};
    ss.color = s.color;
    ss.x = s.x;
    ss.y = s.y;
    ss.shapesize = s.shapesize;
    return ss;
  };

  drawCircle = function(g2d, dotcolor) {
    return function(s) {
      g2d.fillStyle = colorMap[s.color];
      g2d.beginPath();
      g2d.arc(s.x, s.y, s.shapesize / 2, 0, 2 * Math.PI, true);
      g2d.fill();
      g2d.fillStyle = dotcolor;
      g2d.beginPath();
      g2d.arc(s.x, s.y, s.shapesize / 6, 0, 2 * Math.PI, true);
      g2d.closePath();
      return g2d.fill();
    };
  };

  drawSquare = function(g2d, dotcolor) {
    return function(s) {
      var scaledw, x0, y0;
      g2d.fillStyle = colorMap[s.color];
      g2d.fillRect(s.x, s.y, s.shapesize, s.shapesize);
      g2d.fillStyle = dotcolor;
      scaledw = s.shapesize / 3;
      x0 = s.x + scaledw;
      y0 = s.y + scaledw;
      return g2d.fillRect(x0, y0, scaledw, scaledw);
    };
  };

  drawTriangleShape = function(g2d, a, m) {
    g2d.beginPath();
    g2d.moveTo(0, 0);
    g2d.lineTo(a, 0);
    g2d.lineTo(a - m, -a);
    return g2d.closePath();
  };

  drawTriangle = function(g2d, dotcolor) {
    return function(s) {
      var a, m, x0, y0;
      g2d.save();
      x0 = s.x;
      y0 = s.y + s.shapesize;
      g2d.translate(x0, y0);
      g2d.fillStyle = colorMap[s.color];
      a = s.shapesize;
      m = s.shapesize / 2;
      drawTriangleShape(g2d, a, m);
      g2d.fill();
      g2d.restore();
      g2d.save();
      x0 = s.x + m;
      y0 = s.y + 1.25 * m;
      g2d.fillStyle = dotcolor;
      g2d.beginPath();
      g2d.arc(x0, y0, s.shapesize / 6, 0, 2 * Math.PI, true);
      g2d.closePath();
      g2d.fill();
      return g2d.restore();
    };
  };


  /*
     Bounding box for different shapes
   */

  circleBBox = function(s) {
    var bbox, r;
    r = s.shapesize / 2;
    bbox = {};
    bbox.x = s.x - r;
    bbox.y = s.y - r;
    bbox.w = bbox.h = s.shapesize;
    return bbox;
  };

  squareBBox = function(s) {
    var bbox;
    bbox = {};
    bbox.x = s.x;
    bbox.y = s.y;
    bbox.w = bbox.h = s.shapesize;
    return bbox;
  };

  triangleBBox = squareBBox;


  /*
    Dynamics
      bbox -> gives the bounding for the given shape
      bounds -> the bounds within which the shape has to bounce
      dx, dy -> speed in x, y direction
   */

  bouncingDynamic = function(bbox, bounds) {
    return function(s) {
      var box, dx, dy, x, y;
      box = bbox(s);
      dx = s.dx;
      dy = s.dy;
      if (box.x + box.w > bounds.w) {
        if (dx > 0) {
          dx = -dx;
        }
        if (Math.random() > 0.5) {
          dy = -dy;
        }
        x = bounds.w - box.w;
      } else if (box.y + box.h > bounds.h) {
        if (dy > 0) {
          dy = -dy;
        }
        if (Math.random() > 0.5) {
          dx = -dx;
        }
        y = bounds.h - box.h;
      } else if (box.x <= 0) {
        if (dx < 0) {
          dx = -dx;
        }
        if (Math.random() > 0.5) {
          dy = -dy;
        }
      } else if (box.y <= 0) {
        if (dy < 0) {
          dy = -dy;
        }
        if (Math.random() > 0.5) {
          dx = -dx;
        }
      }
      s.x = s.x + dx;
      s.y = s.y + dy;
      s.dx = dx;
      s.dy = dy;
      return s;
    };
  };

  bouncingCircles = bouncingDynamic(circleBBox, JShapesProperties.bounds);

  bouncingSquares = bouncingDynamic(squareBBox, JShapesProperties.bounds);

  bouncingTriangles = bouncingDynamic(triangleBBox, JShapesProperties.bounds);

  start = 0;

  stop = 0;

  computeThroughput = (function(_this) {
    return function() {
      var cps, delta, msg;
      if (circleDR !== null) {
        stop = $.now();
        delta = (stop - start) / 1000;
        start = stop;
        cps = circleDR.receivedSamples / delta;
        msg = "" + cps + " circles / sec";
        circleDR.resetStats();
        return $('#CircleFPS').html(msg);
      }
    };
  })(this);

  animate = (function(_this) {
    return function() {
      var blackSpotCirlce, blackSpotSquare, blackSpotTriangle, g2d, whiteSpotCircle, whiteSpotSquare, whiteSpotTriangle;
      g2d = JShapesProperties.g2d();
      g2d.fillStyle = colorMap[ShapeColor.white];
      g2d.fillRect(0, 0, JShapesProperties.bounds.w, JShapesProperties.bounds.h);
      g2d.drawImage(JShapesProperties.logo.img, JShapesProperties.logo.coord.x, JShapesProperties.logo.coord.y);
      whiteSpotCircle = drawCircle(g2d, colorMap[ShapeColor.white]);
      blackSpotCirlce = drawCircle(g2d, colorMap[ShapeColor.black]);
      whiteSpotSquare = drawSquare(g2d, colorMap[ShapeColor.white]);
      blackSpotSquare = drawSquare(g2d, colorMap[ShapeColor.black]);
      whiteSpotTriangle = drawTriangle(g2d, colorMap[ShapeColor.white]);
      blackSpotTriangle = drawTriangle(g2d, colorMap[ShapeColor.black]);
      inCircleCache.map(function(c) {
        return c.forEachN(blackSpotCirlce, c.depth);
      });
      inSquareCache.map(function(c) {
        return c.forEachN(blackSpotSquare, c.depth);
      });
      inTriangleCache.map(function(c) {
        return c.forEachN(blackSpotTriangle, c.depth);
      });
      outCircleRenderCache.map(function(c) {
        return c.forEachN(whiteSpotCircle, 1);
      });
      outSquareCache.map(function(c) {
        return c.forEach(whiteSpotSquare);
      });
      outTriangleCache.map(function(c) {
        return c.forEach(whiteSpotTriangle);
      });
      outCircleRenderCache.map(function(c) {
        var s;
        s = c.readLast();
        return s.map(bouncingCircles).forEach(function(x) {
          return c.write(x);
        });
      });
      outSquareCache = outSquareCache.map(function(c) {
        return c.map(bouncingSquares);
      });
      outTriangleCache = outTriangleCache.map(function(c) {
        return c.map(bouncingTriangles);
      });
      outCircleRenderCache.map(function(c) {
        var f;
        f = function(s) {
          return circleDW.write(stripShape(s));
        };
        return c.forEachN(f, 1);
      });
      outSquareCache.map(function(c) {
        return c.forEach(function(s) {
          return squareDW.write(stripShape(s));
        });
      });
      return outTriangleCache.map(function(c) {
        return c.forEach(function(s) {
          return triangleDW.write(stripShape(s));
        });
      });
    };
  })(this);

  intialiseRenderCache = function(shapeWriter) {
    return function(dynamics) {
      return function(cache, color, shape, samples) {
        if (samples !== 0) {
          cache.write(color, shape);
          shapeWriter.write(shape);
          return intialiseRenderCache(shapeWriter)(dynamics)(cache, color, dynamics(shape), samples - 1);
        }
      };
    };
  };

  initialiseCircleRenderCache = intialiseRenderCache(circleDW)(bouncingCircles);

  publishTopic = function() {
    var color, dwQos, dx, dy, shape, size, ts;
    ts = JShapesProperties.pubTopic();
    color = JShapesProperties.pubShapeColor();
    size = 2 * JShapesProperties.pubShapeSize();
    dx = JShapesProperties.pubShapeSpeedX();
    dy = JShapesProperties.pubShapeSpeedY();
    shape = randomShape(color, size, dx, dy);
    dwQos = JShapesProperties.shapeWriterQos();
    if (ts === 'Circle') {
      if (circleDW === null) {
        circleDW = new dds.DataWriter(runtime, circleTopic, dwQos);
        outCircleCache = z_.Some(new dds.DataCache(1));
        outCircleRenderCache = z_.Some(new DataCache(extraBuffering));
        initialiseCircleRenderCache(outCircleRenderCache, color, shape, extraBuffering);
      }
      return outCircleCache.map(function(c) {
        return c.write(color, shape);
      });
    } else if (ts === 'Square') {
      if (squareDW === null) {
        squareDW = new dds.DataWriter(runtime, squareTopic, dwQos);
        outSquareCache = z_.Some(new dds.DataCache(1));
      }
      return outSquareCache.map(function(c) {
        return c.write(color, shape);
      });
    } else if (ts === "Triangle") {
      if (triangleDW === null) {
        triangleDW = new dds.DataWriter(runtime, triangleTopic, dwQos);
        outTriangleCache = z_.Some(new dds.DataCache(1));
      }
      return outTriangleCache.map(function(c) {
        return c.write(color, shape);
      });
    }
  };

  subscribeTopic = function() {
    var drQos, history, ts;
    ts = JShapesProperties.subTopic();
    drQos = JShapesProperties.shapeReaderQos();
    history = JShapesProperties.subShapeHistory();
    if (ts === "Circle" && circleDR === null) {
      circleDR = new dds.DataReader(runtime, circleTopic, drQos);
      inCircleCache = z_.Some(new dds.DataCache(history + extraBuffering));
      inCircleCache.map(function(c) {
        return c.write(unmatchedSubscriptionShape.color, unmatchedSubscriptionShape);
      });
      return inCircleCache.map(function(c) {
        return dds.bindWithOnce(function(s) {
          return s.color;
        })(circleDR, c, function(c) {
          return c.take(unmatchedSubscriptionShape.color);
        });
      });
    } else if (ts === "Square" && squareDR === null) {
      squareDR = new dds.DataReader(runtime, squareTopic, drQos);
      inSquareCache = z_.Some(new dds.DataCache(history + extraBuffering));
      inSquareCache.map(function(c) {
        return c.write(unmatchedSubscriptionShape.color, unmatchedSubscriptionShape);
      });
      return inSquareCache.map(function(c) {
        return dds.bindWithOnce(function(s) {
          return s.color;
        })(squareDR, c, function(c) {
          return c.take(unmatchedSubscriptionShape.color);
        });
      });
    } else if (ts === "Triangle" && triangleDR === null) {
      triangleDR = new dds.DataReader(runtime, triangleTopic, drQos);
      inTriangleCache = z_.Some(new dds.DataCache(history + extraBuffering));
      inTriangleCache.map(function(c) {
        return c.write(unmatchedSubscriptionShape.color, unmatchedSubscriptionShape);
      });
      return inTriangleCache.map(function(c) {
        return dds.bindWithOnce(function(s) {
          return s.color;
        })(triangleDR, c, function(c) {
          return c.take(unmatchedSubscriptionShape.color);
        });
      });
    }
  };

  runJShapes = function() {
    setInterval("animate()", JShapesProperties.refresh);
    return setInterval("computeThroughput()", 1000);
  };

  clearPS = function(r, rc, w, wc) {
    if (r !== null) {
      r.close();
    }
    if (w !== null) {
      w.close();
    }
    rc = z_.None;
    return wc = z_.None;
  };

  clearCircles = function() {
    clearPS(circleDR, inCircleCache, circleDW, outCircleCache);
    circleDR = circleDW = null;
    return inCircleCache = outCircleCache = z_.None;
  };

  clearSquares = function() {
    clearPS(squareDR, inSquareCache, squareDW, outSquareCache);
    squareDR = squareDW = null;
    return inSquareCache = outSquareCache = z_.None;
  };

  clearTriangles = function() {
    clearPS(triangleDR, inTriangleCache, squareDW, outTriangleCache);
    triangleDR = triangleDW = null;
    return inTriangleCache = outTriangleCache = z_.None;
  };

  this.animate = animate;

  this.computeThroughput = computeThroughput;

  this.runJShapes = runJShapes;

  this.publishTopic = publishTopic;

  this.subscribeTopic = subscribeTopic;

  this.connect = connect;

  this.disconnect = disconnect;

  this.clearTopicPubSub = clearTopicPubSub;

  $(document).ready(function() {
    return runJShapes();
  });

  root.document.getElementById("connectBtn").onclick = this.connect;

  root.document.getElementById("subscribeBtn").onclick = this.subscribeTopic;

  root.document.getElementById("publishBtn").onclick = this.publishTopic;

  root.document.getElementById("clearTPSBtn").onclick = this.clearTopicPubSub;

}).call(this);
