// Generated by CoffeeScript 1.7.1

/*
                             Vortex Web

    This software and documentation are Copyright 2010 to 2014 PrismTech
    Limited and its licensees. All rights reserved. See file:

                           docs/LICENSE.html

    for full copyright notice and license terms.
 */

(function() {
  var CFail, CFailure, CSome, CSuccess, None, ematch, match, omatch, root;

  root = this;


  /** 
  Define the coffez library. It includes a few useful functional abstractions such as Option and Try types.
  @namespace
   */

  this.coffez = {};


  /**
  @memberof coffez
  @class
  @classdesc this class, used with the CSome class defines the Option
  (Maybe) Monad. This monad is used throughout the API to deal with
  operations that may not return a valid result.
   */

  None = {};


  /** 
    returns None whatever the function to apply.
       @param {function} f - the function to apply
       @returns {None} - None object
       @memberof! coffez.None#
       @function map
   */

  None.map = function(f) {
    return None;
  };


  /** 
    returns None whatever the function to apply.
       @param {function} f - the function to apply
       @returns {None} - None object
       @memberof! coffez.None#
       @function flatMap
   */

  None.flatMap = function(f) {
    return None;
  };


  /** 
    returns the Option's value.
       @returns {undefined} - undefined type
       @memberof! coffez.None#
       @function get
   */

  None.get = function() {
    return void 0;
  };


  /** 
    returns the Option's value if the option is non empty, otherwise return the result of evaluating `f`
       @param {function} f - the default value
       @returns {*} - `f` result
       @memberof! coffez.None#
       @function getOrElse
   */

  None.getOrElse = function(f) {
    return f();
  };


  /** 
    returns this Option if it is non empty, otherwise return the result of evaluating `f`.
       @param {function} f - the default value
       @returns {*} - the result of evaluating f
       @memberof! coffez.None#
       @function orElse
   */

  None.orElse = function(f) {
    return f();
  };


  /** 
    returns true if the Option is empty.
       @returns {boolean} - true
       @memberof! coffez.None#
       @function isEmpty
   */

  None.isEmpty = function() {
    return true;
  };


  /**
  @memberof coffez
  @class
  @classdesc this class, used with the None class defines the Option
  (Maybe) Monad. This monad is used throughout the API to deal with
  operations that may not return a valid result.
   */

  CSome = (function() {
    function CSome(value) {
      this.value = value;
    }


    /** 
    returns a Some containing the result of applying `f` to this Option value.
       @param {function} f - the function to apply
       @returns {CSome} - CSome object
       @memberof! coffez.CSome#
       @function map
     */

    CSome.prototype.map = function(f) {
      return new CSome(f(this.value));
    };


    /** 
    returns the result of applying `f` to this Option value.
       @param {function} f - the function to apply
       @returns {*} - f result
       @memberof! coffez.CSome#
       @function flatMap
     */

    CSome.prototype.flatMap = function(f) {
      return f(this.value);
    };


    /** 
    returns the Option's value.
       @returns {*} - option's value
       @memberof! coffez.CSome#
       @function get
     */

    CSome.prototype.get = function() {
      return this.value;
    };


    /** 
    returns the Option's value if the option is non empty, otherwise return the result of evaluating `f`
       @param {function} f - the default value
       @returns {*} - f result
       @memberof! coffez.CSome#
       @function getOrElse
     */

    CSome.prototype.getOrElse = function(f) {
      return this.value;
    };


    /** 
    returns this Option if it is non empty, otherwise return the result of evaluating `f`.
       @param {function} f - the default value
       @returns {Some} - this Option
       @memberof! coffez.CSome#
       @function orElse
     */

    CSome.prototype.orElse = function(f) {
      return this;
    };


    /** 
    returns true if the Option is empty.
       @returns {boolean} - false
       @memberof! coffez.CSome#
       @function isEmpty
     */

    CSome.prototype.isEmpty = function() {
      return false;
    };

    return CSome;

  })();

  CFail = (function() {
    function CFail(what) {
      this.what = what;
    }

    CFail.prototype.map = function(f) {
      throw this.what;
    };

    CFail.prototype.flatMap = function(f) {
      throw this.what;
    };

    CFail.prototype.get = function() {
      throw this.what;
    };

    CFail.prototype.getOrElse = function(f) {
      throw this.what;
    };

    CFail.prototype.orElse = function(f) {
      throw this.what;
    };

    CFail.prototype.isEmpty = function() {
      throw this.what;
    };

    return CFail;

  })();

  CSuccess = (function() {
    function CSuccess(value) {
      this.value = value;
    }

    CSuccess.prototype.map = function(f) {
      return f(this.value);
    };

    CSuccess.prototype.get = function() {
      return this.value;
    };

    CSuccess.prototype.getOrElse = function(f) {
      return this.value;
    };

    CSuccess.prototype.orElse = function(f) {
      return this;
    };

    CSuccess.prototype.isFailure = function() {
      return false;
    };

    CSuccess.prototype.isSuccess = function() {
      return true;
    };

    CSuccess.prototype.toOption = function() {
      return new CSome(this.value);
    };

    CSuccess.prototype.recover = function(f) {
      return this;
    };

    return CSuccess;

  })();

  CFailure = (function() {
    function CFailure(exception) {
      this.exception = exception;
    }

    CFailure.prototype.map = function(f) {
      return None;
    };

    CFailure.prototype.get = function() {
      return this.exception;
    };

    CFailure.prototype.getOrElse = function(f) {
      return f();
    };

    CFailure.prototype.orElse = function(f) {
      return f();
    };

    CFailure.prototype.isFailure = function() {
      return true;
    };

    CFailure.prototype.isSuccess = function() {
      return false;
    };

    CFailure.prototype.toOption = function() {
      return None;
    };

    CFailure.prototype.recover = function(f) {
      return f(this.exception);
    };

    return CFailure;

  })();

  ematch = function(x, y) {
    if (y === void 0) {
      return true;
    } else {
      return x === y;
    }
  };

  omatch = function(a, b) {
    var e, k, m, v;
    m = true;
    for (k in a) {
      v = a[k];
      e = match(v, b[k]);
      m = m && e;
    }
    return m;
  };

  match = function(a, b) {
    switch (typeof a) {
      case 'object':
        switch (typeof b) {
          case 'object':
            return omatch(a, b);
          default:
            return false;
        }
        break;
      case 'function':
        return false;
      case 'undefined':
        return false;
      default:
        switch (typeof b) {
          case 'object':
            return false;
          case 'function':
            return false;
          case 'undefined':
            return true;
          default:
            return ematch(a, b);
        }
    }
  };

  root.coffez.None = None;


  /**
  Utility function to create a `CSome` object
   @memberof coffez#
   @function Some
   @param {*} value - a given optional value
   @returns {CSome} - a `CSome` object
   @see coffez.CSome
   */

  root.coffez.Some = function(value) {
    return new CSome(value);
  };

  root.coffez.Fail = function(what) {
    return new CFail(what);
  };

  root.coffez.Success = function(value) {
    return new CSuccess(value);
  };

  root.coffez.Failure = function(ex) {
    return new CFailure(ex);
  };

  root.coffez.match = match;

}).call(this);
// Generated by CoffeeScript 1.7.1

/*
                             Vortex Web

    This software and documentation are Copyright 2010 to 2014 PrismTech
    Limited and its licensees. All rights reserved. See file:

                           docs/LICENSE.html

    for full copyright notice and license terms.
 */

(function() {
  var root;

  root = this;

  root.dds = {};

  root.dds.runtime = {};

  dds.runtime.controllerPath = '/vortex/controller';

  dds.runtime.readerPrefixPath = '/vortex/reader';

  dds.runtime.writerPrefixPath = '/vortex/writer';

  dds.runtime.controllerURL = function(server) {
    return server + dds.runtime.controllerPath;
  };

  dds.runtime.readerPrefixURL = function(server) {
    return server + dds.runtime.readerPrefixPath;
  };

  dds.runtime.writerPrefixURL = function(server) {
    return server + dds.runtime.writerPrefixPath;
  };

}).call(this);
// Generated by CoffeeScript 1.7.1

/*
                             Vortex Web

    This software and documentation are Copyright 2010 to 2014 PrismTech
    Limited and its licensees. All rights reserved. See file:

                           docs/LICENSE.html

    for full copyright notice and license terms.
 */

(function() {
  var Close, CloseCmd, CloseDataReader, CloseDataReaderCmd, CloseDataWriter, CloseDataWriterCmd, CommandId, Connect, ConnectCmd, ConnectDataReader, ConnectDataReaderCmd, ConnectDataWriter, ConnectDataWriterCmd, ConnectedDataReaderEvt, ConnectedDataWriterEvt, ConnectedRuntimeEvt, CreateDataReader, CreateDataReaderCmd, CreateDataWriter, CreateDataWriterCmd, CreateEntity, CreateTopic, CreateTopicCmd, CreatedDataReaderEvt, CreatedDataWriterEvt, CreatedDataWriterEvt2, CreatedTopicEvt, DataAvailableEvt, Disconnect, DisconnectCmd, DisconnectedDataReaderEvt, DisconnectedDataWriterEvt, DisconnectedRuntimeEvt, EntityKind, ErrorEvt, EventHeader, EventId, Header, OnConnectedDataReader, OnConnectedDataWriter, OnConnectedRuntime, OnCreatedDataReader, OnCreatedDataWriter, OnCreatedTopic, OnDataAvailable, OnDisconnectedDataReader, OnDisconnectedDataWriter, OnDisconnectedRuntime, OnError, WriteData, WriteDataCmd, WriteLog, WriteLogCmd, root;

  root = this;

  CommandId = {
    OK: 0,
    Error: 1,
    Create: 2,
    Connect: 3,
    Disconnect: 4,
    Close: 5,
    Write: 6,
    Log: 7
  };

  EventId = {
    Error: 0,
    Connected: 1,
    Disconnected: 2,
    DataAvailable: 3,
    Create: 4
  };

  EntityKind = {
    Topic: 0,
    DataReader: 1,
    DataWriter: 2,
    Runtime: 3,
    Worker: 4
  };

  root.dds.runtime.EntityKind = EntityKind;

  root.dds.runtime.CommandId = CommandId;

  root.dds.runtime.EventId = EventId;

  Header = function(cmd, ek) {
    return {
      cid: cmd,
      kind: ek
    };
  };

  ConnectCmd = Header(CommandId.Connect, EntityKind.Runtime);

  Connect = function(serverURL, at) {
    return {
      h: ConnectCmd,
      url: serverURL,
      authToken: at
    };
  };

  DisconnectCmd = Header(CommandId.Disconnect, EntityKind.Runtime);

  Disconnect = {
    h: DisconnectCmd
  };

  CloseCmd = Header(CommandId.Close, EntityKind.Runtime);

  Close = {
    h: CloseCmd
  };

  CreateEntity = function(header) {
    return function(t, q, id) {
      return {
        h: header,
        topic: t,
        qos: q,
        eid: id
      };
    };
  };

  CreateTopicCmd = Header(CommandId.Create, EntityKind.Topic);

  CreateTopic = CreateEntity(CreateTopicCmd);

  CreateDataReaderCmd = Header(CommandId.Create, EntityKind.DataReader);

  CreateDataReader = CreateEntity(CreateDataReaderCmd);

  CloseDataReaderCmd = Header(CommandId.Close, EntityKind.DataReader);

  CloseDataReader = CreateEntity(CloseDataReaderCmd);

  CreateDataWriterCmd = Header(CommandId.Create, EntityKind.DataWriter);

  CreateDataWriter = CreateEntity(CreateDataWriterCmd);

  CloseDataWriterCmd = Header(CommandId.Close, EntityKind.DataWriter);

  CloseDataWriter = CreateEntity(CloseDataWriterCmd);

  root.dds.runtime.ConnectCmd = ConnectCmd;

  root.dds.runtime.Connect = Connect;

  root.dds.runtime.DisconnectCmd = DisconnectCmd;

  root.dds.runtime.Disconnect = Disconnect;

  root.dds.runtime.CloseCmd = CloseCmd;

  root.dds.runtime.Close = Close;

  root.dds.runtime.CreateTopicCmd = CreateTopicCmd;

  root.dds.runtime.CreateTopic = CreateTopic;

  root.dds.runtime.CreateDataReaderCmd = CreateDataReaderCmd;

  root.dds.runtime.CreateDataReader = CreateDataReader;

  root.dds.runtime.CreateDataWriterCmd = CreateDataWriterCmd;

  root.dds.runtime.CreateDataWriter = CreateDataWriter;

  root.dds.runtime.CloseDataReaderCmd = CloseDataReaderCmd;

  root.dds.runtime.CloseDataReader = CloseDataReader;

  root.dds.runtime.CloseDataWriterCmd = CloseDataWriterCmd;

  root.dds.runtime.CloseDataWriter = CloseDataWriter;

  ConnectDataWriterCmd = Header(CommandId.Connect, EntityKind.DataWriter);

  ConnectDataWriter = function(addr, id) {
    return {
      h: ConnectDataWriterCmd,
      url: addr,
      eid: id
    };
  };

  WriteDataCmd = Header(CommandId.Write, EntityKind.DataWriter);

  WriteData = function(s, id) {
    return {
      h: WriteDataCmd,
      data: s,
      eid: id
    };
  };

  root.dds.runtime.ConnectDataWriterCmd = ConnectDataWriterCmd;

  root.dds.runtime.ConnectDataWriter = ConnectDataWriter;

  root.dds.runtime.WriteDataCmd = WriteDataCmd;

  root.dds.runtime.WriteData = WriteData;

  ConnectDataReaderCmd = Header(CommandId.Connect, EntityKind.DataWriter);

  ConnectDataReader = function(addr, id) {
    return {
      h: ConnectDataReaderCmd,
      url: addr,
      eid: id
    };
  };

  root.dds.runtime.ConnectDataReaderCmd = ConnectDataReaderCmd;

  root.dds.runtime.ConnectDataReader = ConnectDataReader;

  EventHeader = function(id, ek) {
    return {
      eid: id,
      kind: ek
    };
  };

  ConnectedRuntimeEvt = EventHeader(EventId.Connected, EntityKind.Runtime);

  OnConnectedRuntime = function(endpoint) {
    return {
      h: ConnectedRuntimeEvt,
      url: endpoint
    };
  };

  DisconnectedRuntimeEvt = EventHeader(EventId.Disconnected, EntityKind.Runtime);

  OnDisconnectedRuntime = function(endpoint) {
    return {
      h: DisconnectedRuntimeEvt,
      url: endpoint
    };
  };

  CreatedDataReaderEvt = EventHeader(EventId.Create, EntityKind.DataReader);

  OnCreatedDataReader = function(addr, id) {
    return {
      h: CreatedDataReaderEvt,
      url: addr,
      eid: id
    };
  };

  ConnectedDataReaderEvt = EventHeader(EventId.Connected, EntityKind.DataReader);

  OnConnectedDataReader = function(addr, id) {
    return {
      h: ConnectedDataReaderEvt,
      url: addr,
      eid: id
    };
  };

  DisconnectedDataReaderEvt = EventHeader(EventId.Disconnected, EntityKind.DataReader);

  OnDisconnectedDataReader = function(addr, id) {
    return {
      h: DisconnectedDataReaderEvt,
      url: addr,
      eid: id
    };
  };

  CreatedDataWriterEvt = EventHeader(EventId.Create, EntityKind.DataWriter);

  CreatedDataWriterEvt2 = EventHeader(EventId.Create, EntityKind.DataWriter);

  OnCreatedDataWriter = function(addr, id) {
    return {
      h: CreatedDataWriterEvt,
      url: addr,
      eid: id
    };
  };

  ConnectedDataWriterEvt = EventHeader(EventId.Connected, EntityKind.DataWriter);

  OnConnectedDataWriter = function(addr, id) {
    return {
      h: ConnectedDataWriterEvt,
      url: addr,
      eid: id
    };
  };

  DisconnectedDataWriterEvt = EventHeader(EventId.Disconnected, EntityKind.DataWriter);

  OnDisconnectedDataWriter = function(addr, id) {
    return {
      h: DisconnectedDataWriterEvt,
      url: addr,
      eid: id
    };
  };

  CreatedTopicEvt = EventHeader(EventId.Create, EntityKind.Topic);

  OnCreatedTopic = function(id) {
    return {
      h: CreatedTopicEvt,
      eid: id
    };
  };

  ErrorEvt = function(ek) {
    return EventHeader(EventId.Error, ek);
  };

  OnError = function(ek, what) {
    return {
      h: ErrorEvt(ek),
      msg: what
    };
  };

  DataAvailableEvt = EventHeader(EventId.DataAvailable, EntityKind.DataReader);

  OnDataAvailable = function(d, id) {
    return {
      h: DataAvailableEvt,
      data: d,
      eid: id
    };
  };

  root.dds.runtime.ConnectedRuntimeEvt = ConnectedRuntimeEvt;

  root.dds.runtime.OnConnectedRuntime = OnConnectedRuntime;

  root.dds.runtime.DisconnectedRuntimeEvt = DisconnectedRuntimeEvt;

  root.dds.runtime.OnDisconnectedRuntime = OnDisconnectedRuntime;

  root.dds.runtime.CreatedTopicEvt = CreatedTopicEvt;

  root.dds.runtime.OnCreatedTopic = OnCreatedTopic;

  root.dds.runtime.CreatedDataReaderEvt = CreatedDataReaderEvt;

  root.dds.runtime.OnCreatedDataReader = OnCreatedDataReader;

  root.dds.runtime.ConnectedDataReaderEvt = ConnectedDataReaderEvt;

  root.dds.runtime.OnConnectedDataReader = OnConnectedDataReader;

  root.dds.runtime.DisconnectedDataReaderEvt = DisconnectedDataReaderEvt;

  root.dds.runtime.OnDisconnectedDataReader = OnDisconnectedDataReader;

  root.dds.runtime.CreatedDataWriterEvt = CreatedDataWriterEvt;

  root.dds.runtime.OnCreatedDataWriter = OnCreatedDataWriter;

  root.dds.runtime.ConnectedDataWriterEvt = ConnectedDataWriterEvt;

  root.dds.runtime.OnConnectedDataWriter = OnConnectedDataWriter;

  root.dds.runtime.DisconnectedDataWriterEvt = DisconnectedDataWriterEvt;

  root.dds.runtime.OnDisconnectedDataWriter = OnDisconnectedDataWriter;

  root.dds.runtime.DataAvailableEvt = DataAvailableEvt;

  root.dds.runtime.OnDataAvailable = OnDataAvailable;

  WriteLogCmd = Header(CommandId.Log, EntityKind.Worker);

  WriteLog = function(ek, str) {
    return {
      h: WriteLogCmd,
      kind: ek,
      msg: str
    };
  };

  root.dds.runtime.WriteLogCmd = WriteLogCmd;

  root.dds.runtime.WriteLog = WriteLog;

}).call(this);
// Generated by CoffeeScript 1.7.1

/*
                             Vortex Web

    This software and documentation are Copyright 2010 to 2014 PrismTech
    Limited and its licensees. All rights reserved. See file:

                           docs/LICENSE.html

    for full copyright notice and license terms.
 */

(function() {
  var Runtime, currentScriptPath, drt, getCurrentPath, z_,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  z_ = coffez;


  /** 
  Define the dds.runtime namespace.
  @namespace dds.runtime
   */

  drt = dds.runtime;

  getCurrentPath = function() {
    var scriptFolder, scriptPath, scriptTag;
    scriptTag = document.getElementsByTagName('script');
    scriptTag = scriptTag[scriptTag.length - 1];
    scriptPath = scriptTag.src;
    scriptFolder = scriptPath.substr(0, scriptPath.lastIndexOf('/'));
    return scriptFolder;
  };

  currentScriptPath = '';

  if (typeof document !== 'undefined') {
    currentScriptPath = getCurrentPath();
  }


  /**
  Constructs a DDS Runtime object 
  @constructor
  @classdesc maintains the connection with the server, re-establish the connection 
  if dropped and mediates the `DataReader` and `DataWriter` communication.
   @memberof dds.runtime
   */

  Runtime = (function() {
    function Runtime() {
      this.isClosed = __bind(this.isClosed, this);
      this.isConnected = __bind(this.isConnected, this);
      this.close = __bind(this.close, this);
      this.onRcvWorkerMessage = __bind(this.onRcvWorkerMessage, this);
      this.onSendWorkerMessage = __bind(this.onSendWorkerMessage, this);
      this.onCtrlWorkerMessage = __bind(this.onCtrlWorkerMessage, this);
      this.writeData = __bind(this.writeData, this);
      this.sn = 0;
      this.eidCount = 0;
      this.drmap = {};
      this.dwmap = {};
      this.tmap = {};
      this.onconnect = function(evt) {};
      this.onclose = function(evt) {};
      this.ondisconnect = function(evt) {};
      this.connected = false;
      this.closed = false;
      this.needToReEstablishConnections = false;
      this.ctrlWorker = new Worker("" + currentScriptPath + "/control-link.js");
      this.sendWorker = new Worker("" + currentScriptPath + "/writer-link.js");
      this.rcvWorker = new Worker("" + currentScriptPath + "/reader-link.js");
      this.ctrlWorker.onmessage = this.onCtrlWorkerMessage;
      this.sendWorker.onmessage = this.onSendWorkerMessage;
      this.rcvWorker.onmessage = this.onRcvWorkerMessage;
      this.server = "disconnected";
    }

    Runtime.prototype.generateEntityId = function() {
      var id;
      id = this.eidCount;
      this.eidCount += 1;
      return id;
    };


    /** 
    Connect the runtime to the server. If the runtime is already connected an exception is thrown
        @param {string} srv - Vortex Web server WebSocket URL
        @param {string} authToken - Authorization token
    @memberof! dds.runtime.Runtime#
    @function connect
     */

    Runtime.prototype.connect = function(srv, authToken) {
      var cmd;
      this.server = srv;
      console.log("[Log]: connect(" + this.server + ")");
      if (!this.connected) {
        this.connected = true;
        cmd = drt.Connect(this.server, authToken);
        return this.ctrlWorker.postMessage(cmd);
      } else {
        throw "Runtime already Connected";
      }
    };


    /**
     Disconnects, withouth closing, a `Runtime`. Notice that upon re-connection all existing
     subscriptions and publications will be re-restablished.
     @memberof! dds.runtime.Runtime#
     @function disconnect
     */

    Runtime.prototype.disconnect = function() {
      if (this.connected) {
        console.log("[Log]: disconnecting...");
        this.connected = false;
        this.ctrlWorker.postMessage(drt.Disconnect);
        this.sendWorker.postMessage(drt.Disconnect);
        this.rcvWorker.postMessage(drt.Disconnect);
      }
      return this.ondisconnect(this.server);
    };

    Runtime.prototype.createDataWriter = function(dw) {
      var cdw;
      console.log("[Log]: Setup DataWriter: " + dw.eid);
      this.dwmap[dw.eid] = dw;
      cdw = drt.CreateDataWriter(dw.topic.tinfo, dw.qos, dw.eid);
      return this.ctrlWorker.postMessage(cdw);
    };

    Runtime.prototype.createDataReader = function(dr) {
      var cdr;
      console.log("[Log]: Setting up DR with eid = " + dr.eid);
      this.drmap[dr.eid] = dr;
      cdr = drt.CreateDataReader(dr.topic.tinfo, dr.qos, dr.eid);
      return this.ctrlWorker.postMessage(cdr);
    };


    /**
     Registers the provided Topic.
     @memberof! dds.runtime.Runtime#
     @function registerTopic
     @param {Topic} t - Topic to be registered
     */

    Runtime.prototype.registerTopic = function(t) {
      var ct, eid;
      console.log("[Log]: Defining topic " + t.tname);
      eid = this.generateEntityId();
      t.eid = eid;
      this.tmap[eid] = t;
      ct = drt.CreateTopic(t.tinfo, t.qos, t.eid);
      return this.ctrlWorker.postMessage(ct);
    };

    Runtime.prototype.unregisterTopic = function(t) {};

    Runtime.prototype.closeDataReader = function(dr) {};

    Runtime.prototype.closeDataWriter = function(dw) {};

    Runtime.prototype.writeData = function(dw, s) {
      var cmd, data, sdata;
      data = Array.isArray(s) ? s : [s];
      sdata = JSON.stringify(data);
      cmd = drt.WriteData(sdata, dw.eid);
      return this.sendWorker.postMessage(cmd);
    };

    Runtime.prototype.onCtrlWorkerMessage = function(evt) {
      var cmd, dr, dw, e, eid, _ref, _ref1;
      e = evt.data;
      switch (false) {
        case !z_.match(e.h, drt.ConnectedRuntimeEvt):
          console.log("[Log]: Runtime Connected.");
          if (this.needToReEstablishConnections) {
            console.log("[Log]: Re-establishing DataReaders and DataWriters connections");
            _ref = this.dwmap;
            for (eid in _ref) {
              dw = _ref[eid];
              this.createDataWriter(dw);
            }
            _ref1 = this.drmap;
            for (eid in _ref1) {
              dr = _ref1[eid];
              this.createDataReader(dr);
            }
          } else {
            this.needToReEstablishConnections = true;
          }
          return this.onconnect(e);
        case !z_.match(e.h, drt.DisconnectedRuntimeEvt):
          console.log("[Log]: Runtime Disconnected.");
          return this.ondisconnect(e);
        case !z_.match(e.h, drt.CreatedTopicEvt):
          console.log("[Log]:Topic created with eid = " + e.eid);
          return this.tmap[e.eid].onregistered(e);
        case !z_.match(e.h, drt.CreatedDataReaderEvt):
          console.log("[Log]:DataReader created with eid = " + e.eid);
          cmd = drt.ConnectDataReader(e.url, e.eid);
          return this.rcvWorker.postMessage(cmd);
        case !z_.match(e.h, drt.CreatedDataWriterEvt):
          console.log("[Log]: DataWriter created with eid = " + e.eid);
          cmd = drt.ConnectDataWriter(e.url, e.eid);
          return this.sendWorker.postMessage(cmd);
        case !z_.match(e.h, drt.WriteLogCmd):
          return console.log("[Log: " + e.kind + "]: " + e.msg);
        default:
          return console.log("[Log]: Driver received invalid command from CtrlWorker");
      }
    };

    Runtime.prototype.onSendWorkerMessage = function(evt) {
      var e;
      e = evt.data;
      switch (false) {
        case !z_.match(e.h, drt.ConnectedDataWriterEvt):
          return this.dwmap[e.eid].onconnect(e);
        case !z_.match(e.h, drt.DisconnectedDataWriterEvt):
          return this.dwmap[e.eid].ondisconnect(e);
        case !z_.match(e.h, drt.WriteLogCmd):
          return console.log("[Log: " + e.kind + "]: " + e.msg);
        default:
          return console.log("[Log]: Driver received invalid command from SendWorker");
      }
    };

    Runtime.prototype.onRcvWorkerMessage = function(evt) {
      var e;
      e = evt.data;
      switch (false) {
        case !z_.match(e.h, drt.ConnectedDataReaderEvt):
          return this.drmap[e.eid].onconnect(e);
        case !z_.match(e.h, drt.DisconnectedDataReaderEvt):
          return this.drmap[e.eid].ondisconnect(e);
        case !z_.match(e.h, drt.DataAvailableEvt):
          return this.drmap[e.eid].onDataAvailable(e.data);
        case !z_.match(e.h, drt.WriteLogCmd):
          return console.log("[Log: " + e.kind + "]: " + e.msg);
        default:
          return console.log("[Log]: Driver Received Invalid Command from ReceiveWorker");
      }
    };


    /**
     Closes the DDS runtime and as a consequence all the `DataReaders` and `DataWriters` that belong to this runtime.
     @memberof! dds.runtime.Runtime#
     @function close
     */

    Runtime.prototype.close = function() {
      var closed, connected;
      console.log("Log: Closing runtime. Notice that this shuts down all web workers.");
      if (!closed) {
        closed = true;
        connected = false;
        this.ctrlWorker.postMessage(drt.Disconnect);
        this.sendWorker.postMessage(drt.Disconnect);
        this.rcvWorker.postMessage(drt.Disconnect);
        this.ctrlWorker.terminate();
        this.sendWorker.terminate();
        this.rcvWorker.terminate();
        this.drmap = {};
        this.dwmap = {};
        return this.onclose();
      }
    };


    /**
     Checks whether the Runtime is connected.
     @memberof! dds.runtime.Runtime#
     @function isConnected
     @return {boolean} - `true` if connected, `false` if not
     */

    Runtime.prototype.isConnected = function() {
      return this.connected;
    };


    /**
     Checks whether the Runtime is closed.
     @memberof! dds.runtime.Runtime#
     @function isClosed
     @return {boolean} - `true` if closed, `false` if not
     */

    Runtime.prototype.isClosed = function() {
      return this.closed;
    };

    return Runtime;

  })();

  dds.runtime.Runtime = Runtime;

}).call(this);
// Generated by CoffeeScript 1.7.1

/*
                             Vortex Web

    This software and documentation are Copyright 2010 to 2014 PrismTech
    Limited and its licensees. All rights reserved. See file:

                           docs/LICENSE.html

    for full copyright notice and license terms.
 */

(function() {
  var ContentFilter, DSCommandId, DSEntityKind, DataCache, DataReader, DataWriter, Durability, DurabilityKind, EntityQos, History, HistoryKind, JSONTopicType, JSONTopicTypeName, JSONTopicTypeSupport, KeyValueTopicType, KeyValueTopicTypeName, Partition, PolicyId, Reliability, ReliabilityKind, TimeFilter, Topic, TopicInfo, UserDefinedTopicTypeSupport, controllerPath, controllerURL, createCommand, createHeader, createTopicInfo, exports, isBuiltinTopicType, isJSONTopicType, isKeyValueTopicType, readerPrefixPath, readerPrefixURL, root, typesSupport, writerPrefixPath, writerPrefixURL, z_,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = this;

  z_ = coffez;


  /** 
  Defines the core Vortex-Web-Client javascript library. It includes the JavaScript API for DDS. This API allows web
   applications to share data among them as well as with native DDS applications.
  @namespace dds
   */

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = dds;
    }
    exports.dds = dds;
  } else {
    root.dds = dds;
  }

  dds.VERSION = "1.0.0-RC3";

  PolicyId = {
    History: 0,
    Reliability: 1,
    Partition: 2,
    ContentFilter: 3,
    TimeFilter: 4,
    Durability: 5,
    TransportPriority: 6,
    Ownership: 7,
    OwnershipStrenght: 8
  };


  /*
     History Policy
   */

  HistoryKind = {
    KeepAll: 0,
    KeepLast: 1
  };


  /**
  History Policy
  @memberof dds#
   @property KeepAll - KEEP_ALL qos policy
   @property KeepLast - KEEP_LAST qos policy
   */

  History = {
    KeepAll: {
      id: PolicyId.History,
      k: HistoryKind.KeepAll
    },
    KeepLast: function(depth) {
      var result;
      result = {
        id: PolicyId.History,
        k: HistoryKind.KeepLast,
        v: depth
      };
      return result;
    }
  };


  /*
    Reliability Policy
   */

  ReliabilityKind = {
    Reliable: 0,
    BestEffort: 1
  };


  /**
  Reliability Policy
  @memberof dds#
   @property BestEffort - 'BestEffort' reliability policy
   @property Reliable - 'Reliable' reliability policy
   @example var qos = Reliability.Reliable
   */

  Reliability = {
    BestEffort: {
      id: PolicyId.Reliability,
      k: ReliabilityKind.BestEffort
    },
    Reliable: {
      id: PolicyId.Reliability,
      k: ReliabilityKind.Reliable
    }
  };


  /**
    Partition Policy.
    @memberof dds#
    @function Partition
    @param {...string} p - partition names
    @returns partition - Partition object
    @example var qos = Partition('p1', 'p2')
   */

  Partition = function() {
    var p, plist, policy;
    p = arguments[0], plist = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    policy = {
      id: PolicyId.Partition,
      vs: plist.concat(p)
    };
    return policy;
  };


  /**
   Content Filter Policy.
   @memberof dds#
   @function ContentFilter
   @param {string} expr
   @returns filter - ContentFilter object
   @example var filter = ContentFilter("x>10 AND y<50")
   */

  ContentFilter = function(expr) {
    var contentFilter;
    contentFilter = {
      id: PolicyId.ContentFilter,
      v: expr
    };
    return contentFilter;
  };


  /**
   Time_Based_Filter Policy.
   @memberof dds#
   @function TimeFilter
   @param {number} period - time duration (unit ?)
   @return timeFilter - TimeFilter policy object
   @example var filter = TimeFilter(100)
   */

  TimeFilter = function(duration) {
    var timeFilter;
    timeFilter = {
      id: PolicyId.TimeFilter,
      v: duration
    };
    return timeFilter;
  };


  /*
    Durability Policy
   */

  DurabilityKind = {
    Volatile: 0,
    TransientLocal: 1,
    Transient: 2,
    Persistent: 3
  };


  /**
  Durability Qos Policy
  @memberof dds#
   @property Volatile - Volatile durability policy
   @property TransientLocal - TransientLocal durability policy
   @property Transient - Transient durability policy
   @property Persistent - Persistent durability policy
   */

  Durability = {
    Volatile: {
      id: DurabilityKind.Volatile
    },
    TransientLocal: {
      id: DurabilityKind.TransientLocal
    },
    Transient: {
      id: DurabilityKind.Transient
    },
    Persistent: {
      id: DurabilityKind.Persistent
    }
  };


  /**
    Creates any of the DDS entities quality of service, including DataReaderQos and DataWriterQos. 
    @constructor
      @param {...policy} p - Qos policies 
    
    @classdesc The Entity QoS is represented as a list of Policies.
    @memberof dds
   */

  EntityQos = (function() {
    function EntityQos() {
      var p, ps;
      p = arguments[0], ps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.policies = ps.concat(p);
    }

    EntityQos.prototype.add = function() {
      var p;
      p = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new EntityQos(this.policies.concat(p));
    };

    return EntityQos;

  })();


  /*
    Policy and QoS Exports
   */

  root.dds.HistoryKind = HistoryKind;

  root.dds.History = History;

  root.dds.ReliabilityKind = ReliabilityKind;

  root.dds.Reliability = Reliability;

  root.dds.Partition = Partition;

  root.dds.DurabilityKind = DurabilityKind;

  root.dds.Durability = Durability;

  root.dds.TimeFilter = TimeFilter;

  root.dds.ContentFilter = ContentFilter;


  /**
  Topic quality of service object
  @memberof dds#
  @name TopicQos
  @type {EntityQos}
  @see dds.EntityQos
   */

  root.dds.TopicQos = EntityQos;


  /**
  DataReader quality of service object
  @memberof dds#
  @name DataReaderQos
  @type {EntityQos}
  @see dds.EntityQos
   */

  root.dds.DataReaderQos = EntityQos;


  /**
  DataWriter quality of service object
  @memberof dds#
  @name DataWriterQos
  @type {EntityQos}
  @see dds.EntityQos
   */

  root.dds.DataWriterQos = EntityQos;

  JSONTopicTypeName = "org.omg.dds.types.JSONTopicType";

  JSONTopicType = (function() {
    function JSONTopicType(value) {
      this.value = value;
    }

    return JSONTopicType;

  })();

  KeyValueTopicType = (function() {
    function KeyValueTopicType(key, value) {
      this.key = key;
      this.value = value;
    }

    return KeyValueTopicType;

  })();

  KeyValueTopicTypeName = "org.omg.dds.types.KeyValueTopicType";

  isJSONTopicType = function(t) {
    return t.tname === JSONTopicType;
  };

  isKeyValueTopicType = function(t) {
    return t.name === KeyValueTopicType;
  };

  isBuiltinTopicType = function(t) {
    return isJSONTopicType(t) || isKeyValueTopicType(t);
  };

  JSONTopicTypeSupport = {
    id: 0,
    injectType: function(s) {
      var v;
      v = new JSONTopicType(JSON.stringify(s));
      console.log("InjectedType = " + (JSON.stringify(v)));
      return v;
    },
    extractType: function(s) {
      var v;
      v = JSON.parse(s.value);
      console.log("Extracted Type = " + v);
      return v;
    }
  };

  UserDefinedTopicTypeSupport = {
    id: 1,
    injectType: function(s) {
      return s;
    },
    extractType: function(s) {
      return s;
    }
  };

  typesSupport = [JSONTopicTypeSupport, UserDefinedTopicTypeSupport];

  TopicInfo = (function() {
    function TopicInfo(did, tname, qos, ttype, tregtype) {
      this.did = did;
      this.tname = tname;
      this.qos = qos;
      this.ttype = ttype;
      this.tregtype = tregtype;
    }

    return TopicInfo;

  })();


  /** 
  Creates a `Topic` in the domain `did`, named `tname`, having `qos` Qos,
  for the type `ttype` whose registered name is `tregtype`
  @constructor
    @param {number} did - DDS domain ID 
    @param {string} tname - topic name
    @param {TopicQos} qos - topic Qos
    @param {string} ttype - topic type. If not specified, a generic type is used. 
    @param {string} tregtype - topic registered type name. If not specified, 'ttype' is used. 
    
  @classdesc defines a DDS Topic
  @memberof dds
   */

  Topic = (function() {
    function Topic(did, tname, qos, ttype, tregtype) {
      this.did = did;
      this.tname = tname;
      this.qos = qos;
      this.ttype = ttype;
      this.tregtype = tregtype;
      if (arguments.length < 2) {
        throw "IllegalArgumentException - You need to provide at least did and topic name";
      }
      if (typeof this.did !== "Number") {
        this.did = parseInt(this.did);
        if (this.did === NaN) {
          throw "IllegalArgumentException - did must be an integer";
        }
      }
      this.onregistered = function() {};
      this.onunregistered = function() {};
      switch (arguments.length) {
        case 2:
        case 3:
          ttype = JSONTopicTypeName;
          tregtype = this.ttype;
          this.typeSupportId = JSONTopicTypeSupport.id;
          qos = qos === void 0 ? new dds.TopicQos(Reliability.BestEffort) : qos;
          this.tinfo = new TopicInfo(did, tname, qos, ttype, tregtype);
          break;
        case 4:
          this.typeSupportId = UserDefinedTopicTypeSupport.id;
          tregtype = this.ttype;
          this.tinfo = new TopicInfo(did, tname, qos, ttype, tregtype);
          break;
        default:
          this.typeSupportId = UserDefinedTopicTypeSupport.id;
          this.tinfo = new TopicInfo(did, tname, qos, ttype, tregtype);
      }
    }

    return Topic;

  })();


  /**
  Creates a `DataReader` for a given topic and a specific in a specific DDS runtime
  @constructor
      @param {Runtime} runtime - DDS Runtime
      @param {Topic} topic - DDS Topic
      @param {DataReaderQos} qos - DataReader quality of service
  
  @classdesc A `DataReader` allows to read data for a given topic with a specific QoS. A `DataReader` 
  goes through different states, it is intially disconnected and changes to the connected state 
  when the underlying transport connection is successfully established with the server. At this point 
  a `DataReader` can be explicitely closed or disconnected. A disconnection can happen as the result 
  of a network failure or server failure. Disconnection and reconnections are managed by the runtime.
  @memberof dds
   */

  DataReader = (function() {
    function DataReader(runtime, topic, qos) {
      this.runtime = runtime;
      this.topic = topic;
      this.qos = qos;
      this.close = __bind(this.close, this);
      this.onDataAvailable = __bind(this.onDataAvailable, this);
      this.removeListener = __bind(this.removeListener, this);
      this.resetStats = __bind(this.resetStats, this);
      this.handlers = [];
      this.onclose = function() {};
      this.closed = false;
      this.onconnect = function() {};
      this.ondisconnect = function() {};
      this.connected = false;
      this.eid = this.runtime.generateEntityId();
      this.runtime.createDataReader(this);
      this.receivedSamples = 0;
      this.typeSupport = typesSupport[this.topic.typeSupportId];
    }

    DataReader.prototype.resetStats = function() {
      return this.receivedSamples = 0;
    };


    /** 
    Attaches the  listener `l` to this data reader and returns
    the id associated to the listener.
       @param {function} l - listener code
       @returns {handle} - listener handle
       @memberof! dds.DataReader#
       @function addListener
     */

    DataReader.prototype.addListener = function(l) {
      var idx;
      idx = this.handlers.length;
      this.handlers = this.handlers.concat(l);
      return idx;
    };


    /**
     removes a listener from this data reader.
     @param {number} idx - listener id
     @memberof! dds.DataReader#
     @function removeListener
     */

    DataReader.prototype.removeListener = function(idx) {
      var h;
      h = this.handlers;
      return this.handlers = h.slice(0, idx).concat(h.slice(idx + 1, h.length));
    };

    DataReader.prototype.onDataAvailable = function(m) {
      var d;
      this.receivedSamples += 1;
      d = this.typeSupport.extractType(JSON.parse(m));
      return this.handlers.forEach(function(h) {
        return h(d);
      });
    };


    /**
    closes the DataReader.
    @memberof! dds.DataReader#
    @function close
     */

    DataReader.prototype.close = function() {
      console.log("Closing DR " + this);
      this.closed = true;
      this.runtime.closeDataReader(this);
      return this.onclose();
    };

    return DataReader;

  })();


  /**
  Creates a `DataWriter` for a given topic and a specific in a specific DDS runtime
  @constructor
      @param {Runtime} runtime - DDS Runtime
      @param {Topic} topic - DDS Topic
      @param {DataWriterQos} qos - DataWriter quality of service
  
   @classdesc defines a DDS data writer. This type
   is used to write data for a specific topic with a given QoS. 
   A `DataWriter` goes through different states, it is intially disconnected and changes to the connected
   state when the underlying transport connection is successfully established with the server.
   At this point a `DataWriter` can be explicitely closed or disconnected. A disconnection can happen
   as the result of a network failure or server failure. Disconnection and reconnections are managed by the
   runtime.
   @memberof dds
   */

  DataWriter = (function() {
    function DataWriter(runtime, topic, qos) {
      this.runtime = runtime;
      this.topic = topic;
      this.qos = qos;
      this.write = __bind(this.write, this);
      this.onclose = function() {};
      this.closed = false;
      this.onconnect = function() {};
      this.ondisconnect = function() {};
      this.connected = false;
      this.eid = this.runtime.generateEntityId();
      this.runtime.createDataWriter(this);
      this.typeSupport = typesSupport[this.topic.typeSupportId];
    }


    /**
     Writes one or more samples.
     @param {...data-type} ds - data sample
     @memberof! dds.DataWriter#
     @function write
     */

    DataWriter.prototype.write = function() {
      var ds, xs;
      ds = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      xs = ds.map((function(_this) {
        return function(s) {
          return _this.typeSupport.injectType(s);
        };
      })(this));
      return this.runtime.writeData(this, xs);
    };


    /**
    Closes the DataWriter.
    @memberof! dds.DataWriter#
    @function close
     */

    DataWriter.prototype.close = function() {
      this.closed = true;
      this.socket = new z_.Fail("Invalid State Exception: Can't write on a closed DataWriter");
      this.runtime.closeDataWriter(this);
      return this.onclose();
    };

    return DataWriter;

  })();

  root.dds.Topic = Topic;

  root.dds.DataReader = DataReader;

  root.dds.DataWriter = DataWriter;


  /**
  Constructs a `DataCache` with a given `depth`. If the `cache` parameter
  is present, then the current cache is initialized with this parameter.
  @constructor
      @param {number} depth - cache size 
      @param {map} cache - cache data structure
       
  @classdesc Provides a way of storing and flexibly accessing the
  data received through a `DataReader`. A `DataCache` is organized as
  a map of queues. The depth of the queues is specified at construction
  time.
  @memberof dds
   */

  DataCache = (function() {
    function DataCache(depth, cache) {
      this.depth = depth;
      this.cache = cache;
      this.clear = __bind(this.clear, this);
      this.fold = __bind(this.fold, this);
      if ((this.cache != null) === false) {
        this.cache = {};
      }
      this.listeners = [];
    }


    /**
    Register a listener to be notified whenever data which matches a predicate is written into the cache.
    If no predicate is provided then the listeners is always notified upon data inserion.
    @memberof! dds.DataCache#
    @function addListener
    @param {function} l - listener function
    @param {function} p - predicate
     */

    DataCache.prototype.addListener = function(l, p) {
      var entry, predicate;
      if (predicate === void 0) {
        predicate = function(x) {
          return true;
        };
      }
      entry = {
        predicate: p,
        listener: l
      };
      return this.listeners = this.listeners.concat(entry);
    };


    /**
     Write the element `data` with key `k` into the cache.
     @memberof! dds.DataCache#
     @param {*} k - data key
     @param {*} data - data value
     @returns {*} - the written data value
     @function  write
     */

    DataCache.prototype.write = function(k, data) {
      var v;
      v = this.cache[k];
      if ((v != null) === false) {
        v = [data];
      } else {
        v = v.length < this.depth ? v.concat(data) : v.slice(1, v.lenght).concat(data);
      }
      this.cache[k] = v;
      return this.listeners.forEach(function(e) {
        if (e.predicate(data) === true) {
          return e.listener(data);
        }
      });
    };


    /**
    Same as forEach but applied, for each key, only to the first `n` samples of the cache
    @memberof! dds.DataCache#
    @function forEachN
    @param {function} f - the function to be applied
    @param {integer} n - samples set size
    @returns {Array} - results of the function execution
    @see dds.DataCache#forEach
     */

    DataCache.prototype.forEachN = function(f, n) {
      var k, v, _ref, _results;
      _ref = this.cache;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v.slice(0, +(n - 1) + 1 || 9e9).forEach(f));
      }
      return _results;
    };


    /**
     Execute the function `f` for each element of the cache.
     @memberof! dds.DataCache#
     @param {function} f - the function to be applied
     @returns {Array} - results of the function execution
     @function forEach
     */

    DataCache.prototype.forEach = function(f) {
      var k, v, _ref, _results;
      _ref = this.cache;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v.forEach(f));
      }
      return _results;
    };


    /**
     Returns a cache that is the result of applying `f` to each element of the cache.
     @memberof! dds.DataCache#
     @param {function} f - the function to be applied
     @returns {DataCache} - A cache holding the results of the function execution
     @function map
     */

    DataCache.prototype.map = function(f) {
      var k, result, v, _ref;
      result = {};
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        result[k] = v.map(f);
      }
      return new DataCache(this.depth, result);
    };


    /**
     Returns the list of elements in the cache that satisfy the predicate `f`.
     @memberof! dds.DataCache#
     @function filter
     @param {function} f - the predicate to be applied to filter the cache values
     @returns {Array} - An array holding the filtered values
     */

    DataCache.prototype.filter = function(f) {
      var fv, k, result, rv, v, _i, _len, _ref;
      result = {};
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          fv = v[_i];
          if (f(v)) {
            rv = fv;
          }
        }
        if (rv.length !== 0) {
          result[k] = rv;
        }
      }
      return result;
    };


    /**
     Returns the list of elements in the cache that doesn't satisfy the predicate `f`.
     @memberof! dds.DataCache#
     @function filterNot
     @returns {Array} - An array holding the filtered values
     @see dds.DataCache#filter
     */

    DataCache.prototype.filterNot = function(f) {
      return filter(function(s) {
        return !f(s);
      });
    };


    /**
     Returns the values included in the cache as an array.
     @memberof! dds.DataCache#
     @function read
     @return {Array} - All the cache values
     */

    DataCache.prototype.read = function() {
      var k, result, v, _ref;
      result = [];
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        result = result.concat(v);
      }
      return result;
    };


    /**
     Returns the last value of the cache in an array.
     @memberof! dds.DataCache#
     @function readLast
     @return {Array} - the last value of the cache
     */

    DataCache.prototype.readLast = function() {
      var k, result, v, _ref;
      result = [];
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        result.add(v[v.length(-1)]);
      }
      return result;
    };


    /**
     Returns all the values included in the cache as an array and empties the cache.
     @memberof! dds.DataCache#  
     @function takeAll
     @return {Array} - All the cache values
     */

    DataCache.prototype.takeAll = function() {
      var k, result, tmpCache, v;
      tmpCache = this.cache;
      this.cache = [];
      result = [];
      for (k in tmpCache) {
        v = tmpCache[k];
        result = result.concat(v);
      }
      return result;
    };


    /**
     Returns the `K`ith value of the cache as Monad, ie: `coffez.Some` if it exists, `coffez.None` if not.
     @memberof! dds.DataCache#  
     @function take
     @see coffez.Some
     @see coffez.None
     */

    DataCache.prototype.take = function(k) {
      var v;
      v = this.cache[k];
      this.cache[k] = [];
      if (v === void 0) {
        return z_.None;
      } else {
        return new z_.Some(v);
      }
    };


    /**
     Takes elements from the cache up to when the predicate `f` is satisfied
     @memberof! dds.DataCache#  
     @function takeWithFilter
     @param {function} f - the predicate
     @return {Array} - taken cache values
     */

    DataCache.prototype.takeWithFilter = function(f) {
      var e, k, result, rv, tv, v, _i, _j, _len, _len1, _ref;
      result = [];
      _ref = this.cache;
      for (k in _ref) {
        v = _ref[k];
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          e = v[_i];
          if (f(e)) {
            tv = e;
          }
        }
        for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
          e = v[_j];
          if (!f(e)) {
            rv = e;
          }
        }
        result = result.concat(tv);
        this.cache[k] = rv;
      }
      return result;
    };


    /**
    Return `coffez.Some(v)` if there is an element in the cache corresponding to the
    key `k` otherwise it returns `coffez.None`.
     @memberof! dds.DataCache#
     @function get
     @param {*} k - key
     @see coffez.Some
     @see coffez.None
     */

    DataCache.prototype.get = function(k) {
      var v;
      v = this.cache[k];
      if (v === void 0) {
        return z_.None;
      } else {
        return new z_.Some(v);
      }
    };


    /**
     Return `coffez.Some(v)` if there is an element in the cache corresponding to the
     key `k` otherwise executes `f` and returns its result.
     @memberof! dds.DataCache#   
     @function getOrElse
     @param {*} k - key
     @param {function} f - the function to apply
     */

    DataCache.prototype.getOrElse = function(k, f) {
      var v;
      v = this.cache[k];
      if (v === void 0) {
        return f();
      } else {
        return new z_.Some(v);
      }
    };


    /**
     folds the element of the cache using `z` as the `zero` element and
     `f` as the binary operator.
     @memberof! dds.DataCache#  
     @function fold
     @param z - initial value
     @param {function} f - reduce function
     */

    DataCache.prototype.fold = function(z) {
      return (function(_this) {
        return function(f) {
          var k, r, v, _ref;
          r = z;
          _ref = _this.cache;
          for (k in _ref) {
            v = _ref[k];
            r = r + v.reduceRight(f);
          }
          return r;
        };
      })(this);
    };


    /**
    clears the data cache.
    @memberof! dds.DataCache#   
    @function clear
     */

    DataCache.prototype.clear = function() {
      return this.cache = {};
    };

    return DataCache;

  })();


  /**
  Binds a reader to a cache. Notice that this is a curried function,
   whose first parameter `getkey` provides the key to be used with the
   data provided by the DataReader
   @memberof dds#
   @function bind
   @param {function} getKey - a function returning the topic key
   @returns {function} - a function f(reader, cache) used to bind a DataReader
   to a DataCache so that the received data is written into that cache
   */

  root.dds.bind = function(key) {
    return function(reader, cache) {
      return reader.addListener(function(d) {
        if (Array.isArray(d)) {
          return d.forEach(function(s) {
            return cache.write(key(s), s);
          });
        } else {
          return cache.write(key(d), d);
        }
      });
    };
  };


  /**
  Similar to the 'bind' function, but applies a given 'once' function on the cache before
  being fed by the received data.
   @memberof dds#
   @function bindWithOnce
   @param {function} getKey - a function returning the topic key
   @returns {function} - a function f(reader, cache, once) used to bind a DataReader
   to a DataCache
   */

  root.dds.bindWithOnce = function(key) {
    return function(reader, cache, once) {
      var executedOnce;
      executedOnce = false;
      return reader.addListener(function(d) {
        if (executedOnce === false) {
          once(cache);
          executedOnce = true;
        }
        if (Array.isArray(d)) {
          return d.forEach(function(s) {
            return cache.write(key(s), s);
          });
        } else {
          return cache.write(key(d), d);
        }
      });
    };
  };

  root.dds.DataCache = DataCache;


  /*
    Protocol
   */

  DSEntityKind = {
    Topic: 0,
    DataReader: 1,
    DataWriter: 2
  };

  DSCommandId = {
    OK: 0,
    Error: 1,
    Create: 2,
    Delegate: 3,
    Unregister: 4
  };

  createHeader = function(c, k, s) {
    var h;
    h = {
      cid: c,
      ek: k,
      sn: s
    };
    return h;
  };

  createTopicInfo = function(domainId, topic, qos) {
    var ti;
    ti = {
      did: domainId,
      tn: topic.tname,
      tt: topic.ttype,
      qos: qos.policies
    };
    return ti;
  };

  createCommand = function(cmdId, kind) {
    return function(seqn, topic, qos) {
      var cmd, tb, th;
      th = createHeader(cmdId, kind, seqn);
      tb = createTopicInfo(topic.did, topic, qos);
      cmd = {
        h: th,
        b: tb
      };
      return cmd;
    };
  };

  root.dds.DSEntityKind = DSEntityKind;

  root.dds.DSCommandId = DSCommandId;

  root.dds.createDataReaderCommand = createCommand(DSCommandId.Create, DSEntityKind.DataReader);

  root.dds.createDataWriterCommand = createCommand(DSCommandId.Create, DSEntityKind.DataWriter);

  controllerPath = '/dscript/controller';

  readerPrefixPath = '/dscript/reader';

  writerPrefixPath = '/dscript/writer';

  controllerURL = function(dscriptServer) {
    return dscriptServer + controllerPath;
  };

  readerPrefixURL = function(dscriptServer) {
    return dscriptServer + readerPrefixPath;
  };

  writerPrefixURL = function(dscriptServer) {
    return dscriptServer + writerPrefixPath;
  };

}).call(this);
