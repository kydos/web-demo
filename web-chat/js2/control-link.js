// Generated by CoffeeScript 1.7.1

/*
                             Vortex Web

    This software and documentation are Copyright 2010 to 2014 PrismTech
    Limited and its licensees. All rights reserved. See file:

                           docs/LICENSE.html

    for full copyright notice and license terms.
 */

(function() {
  var ControlLink, CreateDataReaderMsg, CreateDataWriterMsg, CreateTopicMsg, DataReaderInfo, DataWriterInfo, Header, TopicInfo, connected, controlLink, drt, konsole, root, z_;

  importScripts('vortex-web-client.js');


  /*
    Wire  Protocol Messages
   */

  root = this;

  z_ = coffez;

  drt = dds.runtime;

  connected = true;

  Header = function(c, k, s) {
    return {
      cid: c,
      ek: k,
      sn: s
    };
  };

  TopicInfo = function(topic) {
    return {
      did: topic.did,
      tn: topic.tname,
      tt: topic.ttype,
      trt: topic.tregtype,
      qos: topic.qos.policies
    };
  };

  DataReaderInfo = function(topic, qos) {
    return {
      did: topic.did,
      tn: topic.tname,
      qos: qos.policies
    };
  };

  DataWriterInfo = DataReaderInfo;

  CreateTopicMsg = function(seqn, topic) {
    return {
      h: Header(drt.CommandId.Create, drt.EntityKind.Topic, seqn),
      b: TopicInfo(topic)
    };
  };

  CreateDataReaderMsg = function(seqn, topic, qos) {
    return {
      h: Header(drt.CommandId.Create, drt.EntityKind.DataReader, seqn),
      b: DataReaderInfo(topic, qos)
    };
  };

  CreateDataWriterMsg = function(seqn, topic, qos) {
    return {
      h: Header(drt.CommandId.Create, drt.EntityKind.DataWriter, seqn),
      b: DataWriterInfo(topic, qos)
    };
  };

  konsole = {};

  konsole.log = function(msg) {
    var cmd;
    cmd = drt.WriteLog(drt.EntityKind.Worker, msg);
    return root.postMessage(cmd);
  };

  ControlLink = (function() {
    function ControlLink() {
      this.connected = false;
      this.closed = false;
      this.socket = z_.None;
      this.ctrlSock = z_.None;
      this.server = "";
      this.authToken = "";
      this.sn = 0;
      this.drmap = {};
      this.dwmap = {};
      this.tmap = {};
    }

    ControlLink.prototype.connect = function(url, atoken) {
      var endpoint, pendingCtrlSock, webSocket;
      if (this.connected === false) {
        this.server = url;
        this.authToken = atoken;
        endpoint = drt.controllerURL(this.server) + '/' + this.authToken;
        konsole.log("Connecting to: " + endpoint);
        this.ctrlSock = z_.None;
        webSocket = new WebSocket(endpoint);
        pendingCtrlSock = z_.Some(webSocket);
        pendingCtrlSock.map(((function(_this) {
          return function(s) {
            return s.onopen = function() {
              var evt;
              konsole.log('Connected to: ' + _this.server);
              _this.ctrlSock = pendingCtrlSock;
              _this.connected = true;
              evt = drt.OnConnectedRuntime(_this.server);
              return postMessage(evt);
            };
          };
        })(this)));
        pendingCtrlSock.map(((function(_this) {
          return function(s) {
            return s.onclose = function(evt) {
              konsole.log("The  " + _this.server + " seems to have dropped the connection.");
              _this.connected = false;
              _this.closed = true;
              _this.ctrlSock = z_.None;
              return postMessage(drt.OnDisconnectedRuntime(_this.server));
            };
          };
        })(this)));
        return pendingCtrlSock.map(((function(_this) {
          return function(s) {
            return s.onmessage = function(msg) {
              return _this.handleMessage(msg);
            };
          };
        })(this)));
      } else {
        return konsole.log("Warning: Trying to connect an already connected Runtime");
      }
    };

    ControlLink.prototype.close = function() {
      if (!this.closed) {
        this.closed = true;
        return this.disconnect();
      }
    };

    ControlLink.prototype.disconnect = function() {
      if (this.connected) {
        this.connected = false;
        this.ctrlSock.map(function(s) {
          return s.close();
        });
        return this.crtSock = z_._None;
      }
    };

    ControlLink.prototype.createTopic = function(topic, qos, eid) {
      var cmd, scmd;
      konsole.log("[Log]: Creating Topic for eid = " + eid);
      cmd = CreateTopicMsg(this.sn, topic);
      this.tmap[this.sn] = eid;
      this.sn = this.sn + 1;
      scmd = JSON.stringify(cmd);
      return this.ctrlSock.map(function(s) {
        return s.send(scmd);
      });
    };

    ControlLink.prototype.createDataReader = function(topic, qos, eid) {
      var cmd, scmd;
      cmd = CreateDataReaderMsg(this.sn, topic, qos);
      this.drmap[this.sn] = eid;
      this.sn = this.sn + 1;
      scmd = JSON.stringify(cmd);
      return this.ctrlSock.map(function(s) {
        return s.send(scmd);
      });
    };

    ControlLink.prototype.createDataWriter = function(topic, qos, eid) {
      var cmd, scmd;
      cmd = CreateDataWriterMsg(this.sn, topic, qos);
      this.dwmap[this.sn] = eid;
      this.sn = this.sn + 1;
      scmd = JSON.stringify(cmd);
      return this.ctrlSock.map(function(s) {
        return s.send(scmd);
      });
    };

    ControlLink.prototype.handleMessage = function(s) {
      var evt, guid, msg, url;
      konsole.log("CtrlWorker Received messasge from server:" + s.data);
      msg = JSON.parse(s.data);
      switch (false) {
        case !z_.match(msg.h, {
            cid: drt.CommandId.OK,
            ek: drt.EntityKind.DataReader
          }):
          guid = msg.b.eid;
          url = drt.readerPrefixURL(this.server) + '/' + guid;
          konsole.log("sn = " + msg.h.sn + ", eid = " + this.drmap[msg.h.sn]);
          evt = drt.OnCreatedDataReader(url, this.drmap[msg.h.sn]);
          delete this.drmap[msg.h.sn];
          return postMessage(evt);
        case !z_.match(msg.h, {
            cid: drt.CommandId.OK,
            ek: drt.EntityKind.DataWriter
          }):
          guid = msg.b.eid;
          url = drt.writerPrefixURL(this.server) + '/' + guid;
          konsole.log("sn = " + msg.h.sn + ", eid = " + this.dwmap[msg.h.sn]);
          evt = drt.OnCreatedDataWriter(url, this.dwmap[msg.h.sn]);
          delete this.dwmap[msg.h.sn];
          return postMessage(evt);
        case !z_.match(msg.h, {
            cid: drt.CommandId.OK,
            ek: drt.EntityKind.Topic
          }):
          konsole.log("Topic sn = " + msg.h.sn + "  eid = " + this.tmap[msg.h.sn]);
          evt = drt.OnCreatedTopic(this.tmap[msg.h.sn]);
          delete this.tmap[msg.h.sn];
          return postMessage(evt);
        case !z_.match(msg.h, {
            cid: drt.CommandId.Error,
            ek: void 0
          }):
          evt = OnError(msg.h.ek, msg.b.msg);
          return postMessage(evt);
        default:
          return konsole.log("ControlLink received invalid message from server");
      }
    };

    return ControlLink;

  })();

  controlLink = new ControlLink();

  root.onmessage = function(evt) {
    var cmd;
    cmd = evt.data;
    konsole.log("CtrlWorker received cmd: " + JSON.stringify(cmd));
    switch (false) {
      case !z_.match(cmd.h, drt.ConnectCmd):
        konsole.log("[control-link]: cmd = Connect (" + cmd.url + ")");
        return controlLink.connect(cmd.url, cmd.authToken);
      case !z_.match(cmd.h, drt.CreateTopicCmd):
        return controlLink.createTopic(cmd.topic, cmd.qos, cmd.eid);
      case !z_.match(cmd.h, drt.CreateDataReaderCmd):
        konsole.log("CreateDataReader: " + cmd.eid);
        return controlLink.createDataReader(cmd.topic, cmd.qos, cmd.eid);
      case !z_.match(cmd.h, drt.CreateDataWriterCmd):
        konsole.log("CreateDataWriter: " + cmd.eid);
        return controlLink.createDataWriter(cmd.topic, cmd.qos, cmd.eid);
      case !z_.match(cmd.h, drt.Disconnect):
        return controlLink.disconnect();
      default:
        return konsole.log("Worker Received Unknown Command!");
    }
  };

}).call(this);
